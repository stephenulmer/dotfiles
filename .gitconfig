##
## Identity and Credentials
##
[user]
	name = Stephen Ulmer
	email = ulmer@ulmer.org
	signingkey = ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIL678Vyxez0NwOwQ2EdHYuu57m4aIdLQDBonl4wnC1WX

##
## sub-command (behavioral) defaults
##
[commit]
	gpgsign = true
[init]
	defaultBranch = main
[push]
	followTags = true
[stash]
	showIncludeUntracked = true

##
##
##
[alias]
	root = rev-parse --show-toplevel
	repo = "!basename $(git root);"

	# replacement for for-each-repo that prints each repo
	# before running command
	#   $1 = muti-value variable with list of WORKDIRs
	#   $@:2 = git command and arguments for each repo
	foreach = "! f() { \
	  for r in $(git config get --all ${1}); do \
	    d=$(eval echo ${r}); \
	    t=$(git config get $(echo ${1} | cut -d. -f1-2).top); \
	    b=${d#$t/}; \
	    echo \"\n===> ${b}\"; \
	    git -C ${d} ${@:2}; \
	  done }; f"

	# update the project repo list in ~/.gitconfig-projects
	# starts at project.$1.top, finds all git repos, adds an entry
	# for project.$1.repo for each one
	update-project = "! f() { \
	  top=$(eval echo $(git config --get project.$1.top)); \
	  repos=$(find ${top} -type d -name .git); \
	  cfile=$(eval echo ~/.gitconfig-projects); \
	  git config unset --file ${cfile} --all project.$1.repo; \
	  for repo in ${repos}; do \
	    git config set --file ${cfile} --append project.$1.repo $(dirname ${repo}); \
	  done }; f"

	# set up a project in ~/.gitconfig-projects
	#   [alias]
	#   [project "$1"]
	#   [includeIf "gitdir:~/.gitconfig-$2"]
	# parameters:
	#   $1 = project name (slug)
	#   $2 = (optional) ~/.gitconfig-* file suffix to include
	setup-project = "! f() { \
	  cfile=$(eval echo ~/.gitconfig-projects); \
	  ifile=$(eval echo ~/.gitconfig-$2); \
	  git config set --file ${cfile} alias.$1 \"foreach project.$1.repo\"; \
	  git config set --file ${cfile} project.$1.top $(pwd); \
	  if [ -f "~/.gitconfig-$2" ]; then \
	    git config set --file ${cfile} includeIf.gitdir:$(pwd)/.path ${ifile}; \
	  fi; \
	  }; f"

	# Ensure that gpg.ssh.allowedSignersFile is configured for the current
	# repo. If the config isn't set, use any existing files in the following
	# order:
	#   SIGNERS
	#   .git/allowed_signers
	# If none exist, use the last as a default.
	setup-allowed-signers = "!sh -c ' \
	  cd $(git root) ; \
	  default=\"$(git rev-parse --git-dir)/allowed_signers\" ; \
	  locations=\"SIGNERS ${default}\" ; \
	  signers=$(git config --local gpg.ssh.allowedSignersFile) ; \
	  if [ -z ${signers} ] ; then \
	    for s in ${locations} ; do \
	      signers=${s} ; \
	      if [ -f ${signers} ] ; then break ; fi ; \
	    done ; \
	    git config --local gpg.ssh.allowedSignersFile ${signers} ; \
	  fi ; \
	  git update-allowed-signers ; \
	'"

	# Add the currently configured ssh signing key to the
	# file pointed to by 'gpg.ssh.allowedSignersFile'.
	update-allowed-signers = "!sh -c ' \
	  signers=$(git config --local gpg.ssh.allowedSignersFile) ; \
	  if [ -z ${signers} ] ; then \
	    echo "gpg.ssh.allowedSignersFile is not set!" ; \
	    exit ; \
	  fi ; \
	  myline=\"$(git config user.email) $(git config user.signingkey)\" ; \
	  grep \"${myline}\" ${signers} > /dev/null 2>&1 ; \
	  if [ $? -ne 0 ] ; then \
	    echo ${myline} >> ${signers} ; \
	  fi ; \
	'"

	contribs = "!git ls-files \
	  | while read f; do \
            git blame -w -M -C -C --line-porcelain "$f" \
            | grep -I '^author '; \
          done \
          | sort -f \
          | uniq -ic \
	  | sort -n \
        "
	logg = log --all --graph --decorate=full --show-signature
	logs = log --all --graph --decorate=short --oneline
	weekly = "log --since='last week Sunday' --pretty='format:%cs %h %s'"
	mains = "branch -av --list '*main' '*master'"

##
## Helpers and Filters
##
[credential "https://github.com"]
	helper = 
	helper = !gh auth git-credential
[credential "https://gist.github.com"]
	helper = 
	helper = !gh auth git-credential
[filter "lfs"]
	process = git-lfs filter-process
	required = true
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
[gpg]
	format = ssh
[gpg "ssh"]
	## If ssh-keygen doesn't work or is too old, we can sign directly with
	## 1Password. Otherwise, just have 1Password provide an agent socket.
	# program = /Applications/1Password.app/Contents/MacOS/op-ssh-sign
[diff "pandoc"]
	textconv = pandoc --to=markdown
	prompt = false
[diff "pdftotext"]
	# using the shell is necessary to reverse the order of arguments
	textconv = sh -c 'pdftotext -layout -enc UTF-8 "$1" -' --
	prompt = false

##
## include project-specific configuration
##
[include]
	path = ~/.gitconfig-projects
